<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AniMuse</title>
  <!-- Fabric 5.3 RC (EraserBrush included) -->
  <script src="https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    body{display:flex;flex-direction:column;align-items:center;margin:0;font-family:sans-serif}
    #toolbar{display:flex;gap:10px;flex-wrap:wrap;margin:12px}
    #toolbar label{display:flex;align-items:center;gap:4px}
    #toolbar input[type="range"]{width:120px}
    canvas{border:1px solid #777;touch-action:none;cursor:crosshair;pointer-events:auto}
    button{padding:4px 10px;cursor:pointer}
    button.active{background:#444;color:#fff}
  </style>
</head>
<body>
  <h3>Animuse</h3>
  <div id="toolbar">
    <label>Color <input type="color" id="colorPicker" value="#000000"></label>
    <label>Size <input type="range" id="sizePicker" min="1" max="40" value="4"></label>
    <div id="toolbar">
      <button id="drawBtn">Draw</button>
      <button id="selectBtn">Select</button>
      <button id="animateBtn">Animate</button>
      <button id="deleteBtn">Delete</button>
      <button id="undoBtn">Undo</button>
      <button id="redoBtn">Redo</button>
    </div>
  </div>
  <canvas id="canvas" width="900" height="600"></canvas>

  <script>
    // Wait for full load to ensure Fabric binds correctly
    window.addEventListener('load', () => {
      /***************** Fabric canvas *****************/
      const canvas = new fabric.Canvas('canvas', { preserveObjectStacking:true });

      // iPad / Safari gesture‑event suppression (safe for desktop browsers)
      const el = canvas.upperCanvasEl;
      el.style.touchAction = 'none'; // disable panning/zooming gestures
      el.addEventListener('gesturestart', e => e.preventDefault(), { passive:false });

      // Keep GSAP & Fabric on the same clock
      gsap.ticker.add(canvas.requestRenderAll.bind(canvas));

      /***************** Brushes *****************/
      const pencil = new fabric.PencilBrush(canvas);
      
      // Selection variables
      let isDrawingRect = false;
      let selectionRect = null;
      let startPoint = null;
      let isRectSelectionMode = false; // Flag to track if we're in rectangle selection or direct selection mode

      /***************** History Management *****************/
      const stateHistory = {
        undoStack: [],
        redoStack: [],
        maxLength: 30, // Maximum number of states to keep in memory
        previousState: null, // Previous state (to push to undo stack)
        currentState: null, // Current state
        isBusy: false, // Flag to prevent recursive calls
        
        // Save the current canvas state
        saveState() {
          // Skip if we're already processing state changes or in the middle of an operation
          if (this.isBusy || isDrawingRect) return;
          
          // Make sure we're not in the middle of a selection operation
          if (selectionRect && canvas.contains(selectionRect)) return;
          
          // Capture the current state as a JSON string
          const newState = JSON.stringify(canvas.toJSON(['selectable', 'evented']));
          
          // Skip if the state is identical to the current one (prevents duplicates)
          if (this.currentState === newState) return;
          
          // If we have a previous state, push it to the undo stack
          if (this.previousState !== null) {
            // Trim the undo stack if it gets too large
            if (this.undoStack.length >= this.maxLength) {
              this.undoStack.shift(); // Remove the oldest state
            }
            
            this.undoStack.push(this.previousState);
            console.log('Previous state saved to undo stack');
            console.log('Undo stack length:', this.undoStack.length);
          }
          
          // Update previous and current state
          this.previousState = this.currentState;
          this.currentState = newState;
          
          // Clear redo stack when a new action is performed
          this.redoStack = [];
          
          // Update button states
          this.updateButtonStates();
        },
        
        // Undo the last action
        undo() {
          if (this.undoStack.length < 1 || this.isBusy) return;
          this.isBusy = true;
          
          try {
            // Discard any active selection first
            canvas.discardActiveObject();
            
            // Get the state we're reverting to
            const prevState = this.undoStack.pop();
            
            // Add current state to redo stack
            this.redoStack.push(this.currentState);
            
            // Update state tracking
            this.previousState = prevState;
            this.currentState = prevState;
            
            console.log('Undoing to previous state');
            console.log('Undo stack length:', this.undoStack.length);
            
            // Load the state
            this.loadCanvasState(prevState);
          } finally {
            // Update button states and release lock
            this.updateButtonStates();
            this.isBusy = false;
          }
        },
        
        // Redo the last undone action
        redo() {
          if (this.redoStack.length < 1 || this.isBusy) return;
          this.isBusy = true;
          
          try {
            // Discard any active selection first
            canvas.discardActiveObject();
            
            // Get state to restore from redo stack
            const nextState = this.redoStack.pop();
            
            // Push current state to undo stack before changing
            this.undoStack.push(this.currentState);
            
            // Update state tracking
            this.previousState = this.currentState;
            this.currentState = nextState;
            
            // Load the state
            this.loadCanvasState(nextState);
          } finally {
            // Update button states and release lock
            this.updateButtonStates();
            this.isBusy = false;
          }
        },
        
        // Load a saved canvas state
        loadCanvasState(stateStr) {
          // Clear canvas first and discard any selections
          canvas.discardActiveObject();
          canvas.clear();
          
          // Parse the JSON string to an object
          const stateObj = JSON.parse(stateStr);
          
          // Load objects from the saved state
          canvas.loadFromJSON(stateObj, () => {
            // Reset the drawing mode based on active button
            if (drawBtn.classList.contains('active')) {
              setDrawMode();
            } else if (selectBtn.classList.contains('active')) {
              setSelectMode();
            }
            
            canvas.requestRenderAll();
          });
        },
        
        // Update undo/redo button states based on stack availability
        updateButtonStates() {
          undoBtn.disabled = this.undoStack.length < 1;
          redoBtn.disabled = this.redoStack.length < 1;
        }
      };

      /***************** UI refs *****************/
      const colorPicker = document.getElementById('colorPicker');
      const sizePicker  = document.getElementById('sizePicker');
      const drawBtn  = document.getElementById('drawBtn');
      const selectBtn = document.getElementById('selectBtn');
      const animateBtn = document.getElementById('animateBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');

      function activateBrush(b){ canvas.freeDrawingBrush = b; }

      function clearActive(){ [drawBtn, selectBtn].forEach(b=>b.classList.remove('active')); }

      /***************** Modes *****************/
      function setDrawMode(){
        canvas.isDrawingMode = true;
        canvas.selection = false;
        canvas.forEachObject(o => { o.selectable = false; o.evented = false; });
        
        // Remove any existing selection events
        canvas.off('mouse:down');
        canvas.off('mouse:move');
        canvas.off('mouse:up');

        pencil.color = colorPicker.value;
        pencil.width = +sizePicker.value;
        pencil.globalCompositeOperation = 'source-over';
        activateBrush(pencil);
        canvas.defaultCursor = 'crosshair';
        clearActive(); drawBtn.classList.add('active');
      }

      function setSelectMode(){
        canvas.isDrawingMode = false;
        canvas.selection = true;
        canvas.forEachObject(o => { o.selectable = true; o.evented = true; });
        
        // Setup combined selection mode with keyboard modifier detection
        canvas.on('mouse:down', onSelectModeDown);
        canvas.on('mouse:move', onSelectModeMove);
        canvas.on('mouse:up', onSelectModeUp);
        
        canvas.defaultCursor = 'default';
        clearActive(); selectBtn.classList.add('active');
      }
      
      /***************** Selection Functions *****************/
      function onSelectModeDown(options) {
        // Check if Alt key is pressed to enter rectangle selection mode
        if (options.e.altKey) {
          const pointer = canvas.getPointer(options.e);
          isDrawingRect = true;
          isRectSelectionMode = true;
          startPoint = { x: pointer.x, y: pointer.y };
          
          // Create initial rectangle at mouse position
          selectionRect = new fabric.Rect({
            left: pointer.x,
            top: pointer.y,
            width: 1,
            height: 1,
            strokeWidth: 2,
            stroke: 'rgba(0, 0, 255, 0.5)',
            fill: 'rgba(0, 0, 255, 0.1)',
            originX: 'left',
            originY: 'top',
            selectable: false,
            evented: false
          });
          
          canvas.add(selectionRect);
          canvas.requestRenderAll();
        } else {
          // Regular selection mode - Fabric handles this automatically
          isRectSelectionMode = false;
        }
      }
      
      function onSelectModeMove(options) {
        if (!isDrawingRect || !isRectSelectionMode) return;
        
        const pointer = canvas.getPointer(options.e);
        
        // Calculate width and height based on current pointer position
        let width = Math.abs(pointer.x - startPoint.x);
        let height = Math.abs(pointer.y - startPoint.y);
        
        // Determine top-left corner position
        let left = pointer.x < startPoint.x ? pointer.x : startPoint.x;
        let top = pointer.y < startPoint.y ? pointer.y : startPoint.y;
        
        selectionRect.set({
          left: left,
          top: top,
          width: width,
          height: height
        });
        
        canvas.requestRenderAll();
      }
      
      function onSelectModeUp(options) {
        // Bug fix: Check drawing flag first, then mode flag
        if (isDrawingRect && isRectSelectionMode) {
          isDrawingRect = false;
          
          // Only proceed with selection if the rectangle has a meaningful size
          if (selectionRect && selectionRect.width > 5 && selectionRect.height > 5) {
            // Select all objects that are contained within the rectangle
            const rect = selectionRect;
            const rectLeft = rect.left;
            const rectTop = rect.top;
            const rectRight = rect.left + rect.width;
            const rectBottom = rect.top + rect.height;
            
            const objectsToSelect = [];
            
            canvas.getObjects().forEach(obj => {
              // Skip the selection rectangle itself
              if (obj === selectionRect) return;
              
              // Get object bounds
              const objCenter = obj.getCenterPoint();
              
              // Check if object's center point is inside the rectangle
              if (objCenter.x >= rectLeft && objCenter.x <= rectRight &&
                  objCenter.y >= rectTop && objCenter.y <= rectBottom) {
                objectsToSelect.push(obj);
              }
            });
            
            // Select the objects
            if (objectsToSelect.length === 1) {
              canvas.setActiveObject(objectsToSelect[0]);
            } else if (objectsToSelect.length > 1) {
              const selection = new fabric.ActiveSelection(objectsToSelect, {
                canvas: canvas
              });
              canvas.setActiveObject(selection);
            }
          }
          
          // Remove the selection rectangle
          if (selectionRect) {
            canvas.remove(selectionRect);
            selectionRect = null;
          }
          
          canvas.requestRenderAll();
        }
      }

      /***************** Delete Function *****************/
      function deleteSelectedObjects() {
        // Get the selected objects
        const activeObject = canvas.getActiveObject();
        
        if (!activeObject) {
          // Nothing selected, show an alert
          alert('Please select an object to delete');
          return false; // Return false to indicate no deletion happened
        }
        
        // Save state before deletion
        stateHistory.saveState();
        
        // Check if multiple objects are selected (ActiveSelection)
        if (activeObject.type === 'activeSelection') {
          // Remove all objects in the active selection group
          const activeObjects = activeObject.getObjects();
          
          // Discard the active selection first to avoid errors
          canvas.discardActiveObject();
          
          // Remove each object in the selection
          activeObjects.forEach(obj => {
            canvas.remove(obj);
          });
        } else {
          // Just a single object
          canvas.remove(activeObject);
        }
        
        canvas.requestRenderAll();
        
        // Save state after deletion - with slight delay to ensure proper rendering
        setTimeout(() => stateHistory.saveState(), 20);
        
        return true; // Return true to indicate deletion happened
      }

      /***************** Toolbar listeners *****************/
      drawBtn.addEventListener('click', setDrawMode);
      selectBtn.addEventListener('click', setSelectMode);
      deleteBtn.addEventListener('click', () => {
        deleteSelectedObjects();
        // State saving is now handled inside the deleteSelectedObjects function
      });
      undoBtn.addEventListener('click', () => stateHistory.undo());
      redoBtn.addEventListener('click', () => stateHistory.redo());

      colorPicker.addEventListener('change', () => pencil.color = colorPicker.value);
      sizePicker.addEventListener('input', () => {
        const w = +sizePicker.value;
        pencil.width = w;
      });

      /***************** Bird Animation *****************/
      function animateSelection() {
        // 1) get selection
        const selected = canvas.getActiveObjects();
        if (!selected.length) {
          return alert('Please select one or more strokes first.');
        }

        // 2) record their positions, then delete
        const positions = selected.map(o => {
          const pt = o.getCenterPoint();  // returns a { x, y } in canvas coords
          return { x: pt.x, y: pt.y, color: o.stroke || '#222'};
        });

        canvas.discardActiveObject();
        selected.forEach(o => canvas.remove(o));
        canvas.requestRenderAll();

        // 3) create birds at those positions
        const birds = [], vel = [];
        const BOUNDS = { w: canvas.getWidth(), h: canvas.getHeight() };
        const NEIGHBOR = 60, MAX_SPEED = 2.5;
        const ALIGN_W = 0.05, COH_W = 0.02, SEP_W = 0.08;

        function createBirdAt(x, y, color = '#222') {
          const body = new fabric.Polygon(
            [ {x:0,y:-6}, {x:8,y:0}, {x:0,y:6}, {x:-8,y:0} ],
            { fill: color, originX: 'center', originY: 'center' }
          );
          const wingL = new fabric.Triangle({
            width:14, height:6, fill:color,
            left:-4, angle:-20, originX:'center', originY:'center'
          });
          const wingR = new fabric.Triangle({
            width:14, height:6, fill:color,
            left: 4, angle:200, originX:'center', originY:'center'
          });
          const bird = new fabric.Group([body, wingL, wingR], {
            selectable: false, left: x, top: y
          });
          canvas.add(bird);
          // flap wings forever
          gsap.to(
            [wingL, wingR],
            { angle:'+=40', duration:0.3, yoyo:true, repeat:-1,
              ease:'sine.inOut', stagger:{ each:0.05 },
              onUpdate: canvas.requestRenderAll.bind(canvas)
            }
          );
          return bird;
        }

        function limit(v) {
          const m = Math.hypot(v.x, v.y);
          if (m > MAX_SPEED) {
            v.x = v.x / m * MAX_SPEED;
            v.y = v.y / m * MAX_SPEED;
          }
        }

        console.log('Flocking birds:', positions);
        // spawn one bird per position
        positions.forEach(pos => {
          birds.push(createBirdAt(pos.x, pos.y, pos.color));
          vel.push({ x: Math.random()*2-1, y: Math.random()*2-1 });
        });

        // 4) flocking loop
        function flock() {
          birds.forEach((b,i) => {
            let ax=0, ay=0, cx=0, cy=0, sx=0, sy=0, cnt=0;
            birds.forEach((o,j) => {
              if (i===j) return;
              const dx = o.left - b.left, dy = o.top - b.top;
              const d = Math.hypot(dx, dy);
              if (d < NEIGHBOR) {
                ax += vel[j].x; ay += vel[j].y;
                cx += o.left; cy += o.top;
                sx -= dx/d;   sy -= dy/d;
                cnt++;
              }
            });
            if (cnt) {
              ax /= cnt; ay /= cnt;
              cx = cx/cnt - b.left;
              cy = cy/cnt - b.top;
            }
            vel[i].x += ax*ALIGN_W + cx*COH_W + sx*SEP_W;
            vel[i].y += ay*ALIGN_W + cy*COH_W + sy*SEP_W;
            limit(vel[i]);

            b.left += vel[i].x;
            b.top  += vel[i].y;
            // bounce on walls
            if (b.left < 0 || b.left > BOUNDS.w) {
              vel[i].x *= -1;
              b.left = Math.max(0, Math.min(BOUNDS.w, b.left));
            }
            if (b.top < 0 || b.top > BOUNDS.h) {
              vel[i].y *= -1;
              b.top = Math.max(0, Math.min(BOUNDS.h, b.top));
            }
            b.angle = Math.atan2(vel[i].y, vel[i].x) * 180/Math.PI;
          });

          canvas.requestRenderAll();
          requestAnimationFrame(flock);
        }

        flock();
      }

      /***************** Apples *****************/

      function getCenters(objs) {
        return objs.map(o => {
          const pt = o.getCenterPoint();
          return { x: pt.x, y: pt.y };
        });
      }

      function swayApples(objs) {
        const drift = 10;    // pixels left/right
        const rock  = 8;     // degrees of rotation
        const dur   = 1.2;   // seconds per half‑cycle

        objs.forEach(o => {
          // 1) pin its center
          const { x, y } = o.getCenterPoint();
          o.set({ originX: 'center', originY: 'center', left: x, top: y });

          // 2) animate both left and angle together
          gsap.to(o, {
            left:  `+=${drift}`,
            angle: `+=${rock}`,
            duration: dur,
            yoyo:   true,
            repeat: -1,
            ease:   'sine.inOut',
            onUpdate: canvas.requestRenderAll.bind(canvas)
          });
        });
      }



      /***************** Animate Button *****************/
      // animateBtn.addEventListener('click', () => {
      //   const action = prompt('What should I do with the selected items?');
      //   if (!action) return;
      //   // for now we ignore `action` and just bird‑ify
      //   animateSelection();
      // });


      animateBtn.addEventListener('click', () => {
        const text = prompt('What should I do with the selected items?') || '';
        const sel = canvas.getActiveObjects();

        if (!sel.length) {
          return alert('Select some strokes first!');
        }

        // birds?
        if (/birds?/i.test(text)) {
          // record centers, delete strokes, then birdify
          animateSelection();

        // apples?
        } else if (/apples?/i.test(text)) {
          // simply apply sway to existing shapes
          canvas.discardActiveObject();
          swayApples(sel);

        } else {
          alert('I only know how to animate “birds” or “apples” for now.');
        }
      });
      
      /***************** Extras *****************/
      // Ensure paths have consistent properties
      canvas.on('path:created', e => {
        e.path.strokeUniform = true;
      });

      // Free memory on removal
      canvas.on('object:removed', e => e.target.dispose && e.target.dispose());

      // Keyboard shortcuts for convenience
      window.addEventListener('keydown', e=>{
        if (e.target !== document.body) return; // ignore if typing in input
        
        // Check for keyboard shortcuts with modifiers
        if (e.ctrlKey || e.metaKey) {
          switch(e.key.toLowerCase()) {
            case 'z':
              if (e.shiftKey) {
                // Ctrl+Shift+Z or Cmd+Shift+Z for Redo
                stateHistory.redo();
              } else {
                // Ctrl+Z or Cmd+Z for Undo
                stateHistory.undo();
              }
              e.preventDefault();
              break;
            case 'y':
              // Ctrl+Y or Cmd+Y for Redo
              stateHistory.redo();
              e.preventDefault();
              break;
          }
        } else {
          // Simple shortcuts (no modifiers)
          switch(e.key){
            case 'd': setDrawMode(); break;
            case 's': setSelectMode(); break;
            case 'Delete': 
              deleteSelectedObjects();
              // State saving is now handled inside the deleteSelectedObjects function
              break; // Delete key for removing objects
          }
        }
      });
      
      // Show instructions
      console.log("Usage: Click 'Select' button and use Alt+click+drag to create a rectangle selection, or just click objects directly to select them");

      // Initialize buttons
      undoBtn.disabled = true;
      redoBtn.disabled = true;
      
      // Register canvas events that should save state
      canvas.on('path:created', () => {
        // Use setTimeout to ensure the state is captured after the path is fully created
        setTimeout(() => stateHistory.saveState(), 20);
      });
      
      canvas.on('object:modified', () => {
        // Use setTimeout to ensure the state is captured after the object is fully modified
        setTimeout(() => stateHistory.saveState(), 20);
      });
      
      // Save initial empty canvas state (first state isn't pushed to undo stack)
      setTimeout(() => {
        const initialState = JSON.stringify(canvas.toJSON(['selectable', 'evented']));
        stateHistory.currentState = initialState;
        stateHistory.previousState = initialState; // Set both to same value initially
        stateHistory.updateButtonStates();
      }, 100);
      
      // Default mode
      setDrawMode();
    });
  </script>
</body>
</html>